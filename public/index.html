<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🇰🇷 Korea Thematic Nowcast Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>body{background:#f8fafc;color:#0f172a}</style>
</head>
<body>
  <div id="app" class="max-w-6xl mx-auto p-6"></div>

  <!-- 설정 상수 (서버와 동일) -->
  <script>
    const TRUST = %TRUST%;
    const RULES = %RULES%;
    const SECTORS = %SECTORS%;
  </script>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    // label -> 포함 섹터
    const MEMBER_SECTORS = (() => {
      const m = {};
      Object.entries(SECTORS).forEach(([sector, arr]) => {
        (arr || []).forEach(label => { (m[label] ||= []).push(sector); });
      });
      return m;
    })();

    function format(n, p=2){ return (n==null||Number.isNaN(n)) ? 'N/A' : n.toFixed(p); }
    function formatPct(n){ if(n==null||Number.isNaN(n)) return 'N/A'; const s = n>=0? '+'+n.toFixed(2)+'%' : n.toFixed(2)+'%'; return s; }

    function App(){
      const [data, setData] = useState(null);
      const [err, setErr] = useState('');
      const [intervalSec, setIntervalSec] = useState(60);
      const [eventMode, setEventMode] = useState(false);
      const [vol, setVol] = useState({});
      const [internal, setInternal] = useState(null);
      const [loading, setLoading] = useState(false);
      const [backDays, setBackDays] = useState(60);
      const [back, setBack] = useState(null);
      const [backLoading, setBackLoading] = useState(false);

      async function load(){
        try{ setLoading(true); const r = await fetch('/api/snapshot'); const j = await r.json(); setData(j); setErr(''); }
        catch(e){ setErr(String(e?.message||e)); }
        finally{ setLoading(false); }
      }
      async function loadVol(){ try{ const r = await fetch('/api/vol'); const j = await r.json(); setVol(j?.std || {}); }catch(e){} }
      async function loadInternal(){ try{ const r = await fetch('/api/internal'); const j = await r.json(); setInternal(j); }catch(e){} }
      async function runBacktest(){ try{ setBackLoading(true); const r = await fetch('/api/backtest?days='+backDays); const j = await r.json(); setBack(j); } finally{ setBackLoading(false); } }

      useEffect(()=>{ load(); }, []);
      useEffect(()=>{ const t=setTimeout(loadVol, 1200); const t2=setTimeout(loadInternal, 1500); return ()=>{ clearTimeout(t); clearTimeout(t2); }; }, []);
      useEffect(()=>{ if(!intervalSec||intervalSec<=0) return; const id=setInterval(load, intervalSec*1000); return ()=>clearInterval(id); }, [intervalSec]);

      const rows = useMemo(()=> data?.results ?? [], [data]);
      const map = useMemo(()=> { const m={}; rows.forEach(r=>{ m[r.label]=r; }); return m; }, [rows]);
      const v = (label)=> map[label]?.chgPct;
      function sectorBase(name){ const mem = SECTORS[name]||[]; const xs = mem.map(l=> v(l)).filter(n=> n!=null && !Number.isNaN(n)); if(xs.length===0) return null; return xs.reduce((a,b)=>a+b,0)/xs.length; }
      function zscore(label, pct){ const s = vol?.[label]; if(pct==null || Number.isNaN(pct)) return 0; const z = (s && s>0)? pct / s : pct; return Math.max(-3, Math.min(3, z)); }

      function makeForecast(){
        const out = [];
        const names = Object.keys(SECTORS);
        for(const name of names){
          let sExt = 0; let used = 0; const reasons = [];
          const trustScale = (TRUST[name]==="높음") ? 1.0 : 0.85;
          const alphaEv = eventMode ? 0.5 : 1.0;
          const base = sectorBase(name);

          for(const r of (RULES[name]||[])){
            const raw = v(r.label);
            if(raw==null) continue;
            const adj = r.invert ? -raw : raw;
            const z = zscore(r.label, adj);
            const intensity = Math.tanh(Math.abs(z));
            const sign = z>0? 1 : -1;
            sExt += sign * (r.w||0.3) * intensity * trustScale * alphaEv;
            reasons.push((r.label) + ' ' + (raw>0 ? '↑' : '↓') + ' (' + formatPct(raw) + ')');
            used++;
          }

          const I = internal?.bySector?.[name];
          if (I && I.n>0){
            const wInt = (TRUST[name]==='높음') ? { b:0.5, l:0.6, d:0.3 } : { b:0.35, l:0.45, d:0.2 };
            sExt += (I.breadthScore||0) * wInt.b * trustScale; reasons.push('Breadth(D-1): ' + (I.breadthScore>0? '긍정':'부정') + ' (' + (Math.abs(I.breadthScore)).toFixed(2) + ')');
            sExt += (I.leaderScore||0)  * wInt.l * trustScale; reasons.push('Leader(D-1): ' + (I.lret>0? '↑':'↓') + ' (' + formatPct(I.lret) + ')');
            sExt += (I.dispScore||0)    * wInt.d * trustScale; reasons.push('Dispersion(D-1): ' + (I.disp>0? I.disp.toFixed(2)+'%' : 'N/A'));
          }

          const score = sExt;
          const dir = score>0.6? '상승' : score<-0.6? '하락' : '중립';
          const arrow = score>0.6? '⬆️' : score<-0.6? '⬇️' : '➡️';
          const confCap = (TRUST[name] === "높음") ? 88 : 78;
          const confidence = Math.min(confCap, Math.round(Math.min(1, Math.abs(score)) * 100));

          out.push({ name, score, dir, arrow, confidence, reasons, base, used });
        }
        return out;
      }

      const fx = useMemo(()=> makeForecast(), [rows, vol, eventMode, internal]);

      return (
        <div className="space-y-5">
          <header className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold">🇰🇷 Korea Thematic — Next-Day Nowcast</h1>
              <p className="text-sm text-slate-600">KOSPI · KOSDAQ · 항셍 · 니케이 · 화장품 · 방산 · 여행 · 자동차 · 조선 · 2차전지 · 전력 · 원자력 · 반도체 · 철강 · 해운 · 재생에너지 · 은행 · 인터넷 · 건설/리츠 · 비료 · 금테마</p>
            </div>
            <div className="flex items-center gap-3">
              <label className="text-sm text-slate-600">자동 새로고침(초)</label>
              <input type="number" min="0" max="600" value={intervalSec} onChange={e=>setIntervalSec(parseInt(e.target.value||'0',10))} className="w-24 rounded-md border px-2 py-1" />
              <label className="text-sm flex items-center gap-2"><input type="checkbox" checked={eventMode} onChange={e=>setEventMode(e.target.checked)} /> 이벤트 모드</label>
              <button onClick={load} className="rounded-xl bg-slate-900 text-white px-3 py-1.5 text-sm">갱신</button>
            </div>
          </header>

          <section className="text-sm text-slate-600">
            <p>마지막 업데이트: <b>{data?.t ? new Date(data.t).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' }) : '-'}</b> {loading && <span className="ml-2 animate-pulse text-slate-500">(불러오는 중…)</span>}</p>
          </section>

          {err && <div className="rounded-lg bg-red-50 border border-red-200 p-3 text-red-700">{err}</div>}

          <section>
            <div className="overflow-x-auto rounded-xl border bg-white">
              <table className="min-w-full text-sm">
                <thead className="bg-slate-100">
                  <tr>
                    <th className="px-3 py-2 text-left">Label</th>
                    <th className="px-3 py-2 text-left">Symbol</th>
                    <th className="px-3 py-2 text-right">Last</th>
                    <th className="px-3 py-2 text-right">Prev Close</th>
                    <th className="px-3 py-2 text-right">Change%</th>
                  </tr>
                </thead>
                <tbody>
                  {(data?.results ?? []).map((r,i)=> (
                    <tr key={i} className={i%2? 'bg-white' : 'bg-slate-50'}>
                      <td className="px-3 py-2">
                        <div className="flex flex-wrap items-center gap-1">
                          <span>{r.label}</span>
                          {(MEMBER_SECTORS[r.label] || []).map((s, k) => (
                            <span key={k} className="inline-block rounded-full bg-slate-100 text-slate-700 px-2 py-0.5 text-[11px]" title="섹터 소속">{s}</span>
                          ))}
                        </div>
                      </td>
                      <td className="px-3 py-2 text-slate-500">{r.symbol}</td>
                      <td className="px-3 py-2 text-right">{(r.symbol==='^TNX'? (r.last?.toFixed?.(3)) : (r.last?.toFixed?.(4))) ?? 'N/A'}</td>
                      <td className="px-3 py-2 text-right">{(r.symbol==='^TNX'? (r.prev?.toFixed?.(3)) : (r.prev?.toFixed?.(4))) ?? 'N/A'}</td>
                      <td className={("px-3 py-2 text-right "+(r.chgPct>0? 'text-green-600' : r.chgPct<0? 'text-red-600':'text-slate-700'))}>{formatPct(r.chgPct)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </section>

          <section className="rounded-xl border bg-white p-4">
            <h3 className="font-semibold mb-2">예측 (Heuristic Nowcast) — 다음 거래일</h3>
            <div className="grid md:grid-cols-2 gap-4">
              {fx.map((f,i)=> (
                <div key={i} className="rounded-xl border p-4 bg-white">
                  <div className="flex items-center justify-between">
                    <div className="font-semibold">{f.name} <span className={(TRUST[f.name]==="높음"?"ml-2 text-[11px] px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-700":"ml-2 text-[11px] px-2 py-0.5 rounded-full bg-amber-100 text-amber-700")}>{TRUST[f.name]||"중간"}</span></div>
                    <div className="text-lg">{f.arrow} <span className="text-slate-600 text-sm">{f.dir} · {f.confidence}%</span></div>
                  </div>
                  <div className="text-slate-600 text-sm mt-1">구성종목 평균(당일): <b>{f.base==null? 'N/A' : (f.base>0? '+'+f.base.toFixed(2): f.base.toFixed(2))+'%'}</b> · 사용 신호: <b>{f.used}</b>개</div>
                  <ul className="list-disc pl-5 text-sm text-slate-700 mt-2">
                    {f.reasons.map((r,j)=>(<li key={j}>{r}</li>))}
                  </ul>
                  <p className="text-xs text-slate-500 mt-2">외생 지표 + D-1 내부 신호(브레드스/리더/디스퍼전) 기반. 투자조언 아님.</p>
                </div>
              ))}
            </div>
          </section>

          <section className="rounded-xl border bg-white p-4">
            <div className="flex items-center justify-between mb-2">
              <h3 className="font-semibold">백테스트 (최근 {back?.days || backDays}일, 현재는 외생 팩터만)</h3>
              <div className="flex items-center gap-2 text-sm">
                <label>기간</label>
                <select value={backDays} onChange={e=>setBackDays(parseInt(e.target.value,10))} className="border rounded px-2 py-1">
                  <option value="30">30</option>
                  <option value="60">60</option>
                  <option value="90">90</option>
                </select>
                <button onClick={runBacktest} className="rounded bg-slate-900 text-white px-3 py-1.5">{backLoading? '실행중…' : '실행'}</button>
              </div>
            </div>
            {back ? (
              <div className="overflow-x-auto rounded-lg border">
                <table className="min-w-full text-sm">
                  <thead className="bg-slate-100">
                    <tr>
                      <th className="px-3 py-2 text-left">섹터/지수</th>
                      <th className="px-3 py-2 text-right">표본수</th>
                      <th className="px-3 py-2 text-right">적중률</th>
                    </tr>
                  </thead>
                  <tbody>
                    {back.results.map((r,i)=> (
                      <tr key={i} className={i%2? 'bg-white':'bg-slate-50'}>
                        <td className="px-3 py-2">{r.name}</td>
                        <td className="px-3 py-2 text-right">{r.samples}</td>
                        <td className="px-3 py-2 text-right">{r.hitPct==null? 'N/A' : (r.hitPct.toFixed ? r.hitPct.toFixed(1)+'%' : r.hitPct+'%')}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            ) : (
              <p className="text-sm text-slate-500">버튼을 눌러 최근 {backDays}일 적중률을 계산해 보세요. (구성종목 당일 변화는 제외)</p>
            )}
            <p className="text-xs text-slate-500 mt-2">메모: 내부 신호를 포함한 과거 백테스트는 연산량이 커 다음 단계에서 추가 예정입니다.</p>
          </section>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('app')).render(<App />);
  </script>

  <script>
    // 서버에서 빌드시 %PLACEHOLDER% 치환 (간단 빌드 없이도 동작하도록 기본 삽입)
    // 아래는 개발 편의를 위해 서버 설정과 동일한 객체를 인라인한 예시입니다.
    // 필요시 /src/config/*.js에서 내용을 복붙해 교체하세요.
  </script>
</body>
</html>
